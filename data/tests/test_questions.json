[{
    "question": "LCEL(LangChain Expression Language)이 무엇인가요? 그리고 왜 사용하나요?",
    "expected_answer": "LCEL은 파이프라인처럼 체인을 구성할 수 있게 해주는 선언적 언어입니다. 스트리밍, 병렬 처리, 비동기 지원 등 프로덕션 환경에 필요한 기능을 쉽게 구현할 수 있어 사용됩니다.",
    "source": "https://python.langchain.com/docs/expression_language/"
  },
  {
    "question": "RAG 체인에서 검색된 문서의 출처(source)는 어떻게 답변에 포함시키나요?",
    "expected_answer": "검색된 Document 객체의 metadata 딕셔너리에 포함된 'source' 키 값을 참조하여 답변과 함께 제공할 수 있습니다. 보통 프롬프트 템플릿 단계에서 이를 처리합니다.",
    "source": "https://python.langchain.com/docs/use_cases/question_answering/sources"
  },
  {
    "question": "LangChain에서 Agent는 어떻게 작동하나요?",
    "expected_answer": "Agent는 LLM을 추론 엔진으로 사용하여, 어떤 행동을 취할지 결정하고, 도구(Tools)를 실행하며, 그 결과를 관찰하여 최종 답변을 찾을 때까지 과정을 반복합니다.",
    "source": "https://python.langchain.com/docs/modules/agents/"
  },
  {
    "question": "챗봇에 대화 기록을 유지하려면 어떤 기능을 사용해야 하나요?",
    "expected_answer": "LangChain의 Memory 컴포넌트를 사용합니다. ConversationBufferMemory와 같은 클래스를 체인에 추가하여 이전 대화 내용을 기억하고 다음 답변에 활용할 수 있습니다.",
    "source": "https://python.langchain.com/docs/modules/memory/"
  },
  {
    "question": "PDF 파일에서 텍스트를 추출하려면 어떤 Document Loader를 사용해야 하나요?",
    "expected_answer": "PyPDFLoader를 사용하여 PDF 파일의 내용을 페이지별로 나누어 Document 객체로 로드할 수 있습니다.",
    "source": "https://python.langchain.com/docs/modules/data_connection/document_loaders/pdf"
  },
  {
    "question": "웹사이트의 내용을 스크래핑하여 문서로 가져오는 Loader는 무엇인가요?",
    "expected_answer": "WebBaseLoader를 사용하면 URL을 전달하여 웹 페이지의 HTML 콘텐츠를 파싱하고 텍스트를 추출하여 문서로 만들 수 있습니다.",
    "source": "https://python.langchain.com/docs/modules/data_connection/document_loaders/web_base"
  },
  {
    "question": "RecursiveCharacterTextSplitter는 다른 Text Splitter와 비교했을 때 어떤 특징이 있나요?",
    "expected_answer": "RecursiveCharacterTextSplitter는 ['\n\n', '\n', ' ', '']와 같은 구분자 목록을 순서대로 시도하여 텍스트를 의미적으로 최대한 연결된 상태로 분할하려는 특징이 있습니다.",
    "source": "https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/recursive_character"
  },
  {
    "question": "ChromaDB 벡터스토어에 연결하고 컬렉션을 생성하는 기본 코드를 보여주세요.",
    "expected_answer": "import chromadb; client = chromadb.Client(); collection = client.create_collection('my_collection') 코드를 통해 클라이언트를 초기화하고 컬렉션을 생성할 수 있습니다.",
    "source": "https://python.langchain.com/docs/integrations/vectorstores/chroma/"
  },
  {
    "question": "LLM의 답변을 JSON 형식으로 구조화하려면 어떤 Output Parser를 사용해야 하나요?",
    "expected_answer": "PydanticOutputParser 또는 JsonOutputParser를 사용합니다. Pydantic 모델을 정의하고 파서에 주입하면, LLM이 해당 스키마에 맞는 JSON 형식의 답변을 생성하도록 유도할 수 있습니다.",
    "source": "https://python.langchain.com/docs/modules/model_io/output_parsers/json"
  },
  {
    "question": "Agent가 사용할 수 있는 사용자 정의 도구(Custom Tool)는 어떻게 만드나요?",
    "expected_answer": "@tool 데코레이터를 사용하여 함수를 정의하면 간단하게 사용자 정의 도구를 만들 수 있습니다. 함수에는 이름, 설명, 그리고 인자에 대한 명확한 docstring을 작성해야 합니다.",
    "source": "https://python.langchain.com/docs/modules/agents/tools/custom_tools"
  },
  {
    "question": "LCEL을 사용해서 prompt, model, output parser를 연결하는 가장 기본적인 체인 코드 예시를 보여주세요.",
    "expected_answer": "from langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_openai import ChatOpenAI\n\nprompt = ChatPromptTemplate.from_template('tell me a joke about {topic}')\nmodel = ChatOpenAI()\noutput_parser = StrOutputParser()\n\nchain = prompt | model | output_parser\n\nchain.invoke({'topic': 'ice cream'})",
    "source": "https://python.langchain.com/docs/expression_language/get_started"
  },
{
  "question": "PydanticOutputParser를 사용하는 전체 코드 예제를 보여주세요.",
  "expected_answer": "from langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_openai import ChatOpenAI\n\nprompt = ChatPromptTemplate.from_template('tell me a joke about {topic}')\nmodel = ChatOpenAI()\noutput_parser = StrOutputParser()\n\nchain = prompt | model | output_parser\n\nchain.invoke({'topic': 'ice cream'})",
  "source": "https://python.langchain.com/docs/modules/model_io/output_parsers/pydantic"
}
,
{
  "question": "ConversationBufferMemory를 RAG 체인에 추가하는 코드 예시를 알려주세요.",
  "expected_answer": "from langchain.memory import ConversationBufferMemory\n\nmemory = ConversationBufferMemory(memory_key='chat_history', return_messages=True)\n\nchain = RunnableWithMessageHistory(\n    runnable=rag_chain, \n    get_session_history=lambda session_id: ... , \n    input_messages_key='question', \n    history_messages_key='chat_history'\n)",
  "source": "https://python.langchain.com/docs/expression_language/how_to/message_history"
}
,
{
  "question": "WebBaseLoader를 사용하여 웹 페이지 내용을 로드하고, RecursiveCharacterTextSplitter로 분할하는 코드 예시를 보여주세요.",
  "expected_answer": "from langchain_community.document_loaders import WebBaseLoader\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n\nloader = WebBaseLoader('https://lilianweng.github.io/posts/2023-06-23-agent/')\ndocs = loader.load()\n\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)\nsplits = text_splitter.split_documents(docs)",
  "source": "https://python.langchain.com/docs/how_to/recursive_splitter"
}
,
{
  "question": "RunnablePassthrough를 사용해서 retriever가 찾은 context를 LLM에 전달하는 코드 예시를 보여주세요.",
  "expected_answer": "from langchain_core.runnables import RunnablePassthrough\n\nretriever = vector.as_retriever()\n\ndef format_docs(docs):\n    return '\\n\\n'.join(doc.page_content for doc in docs)\n\nchain = (\n    {'context': retriever | format_docs, 'question': RunnablePassthrough()}\n    | prompt\n    | model\n    | StrOutputParser()\n)",
  "source": "https://python.langchain.com/docs/expression_language/how_to/retrieval_chain"
}

]